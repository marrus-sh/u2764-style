<!DOCTYPE html>
<html lang="en">
<title>Tendency Style</title>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,intial-scale=1"/>

<style>
/* Layout and sectioning */
@media screen {
	html { Background: Fixed Repeat-Y Linear-Gradient(
		To Left,
		#FAF8F7 30CH,
		#DEDBD9 42CH,
		#B8B3B0 54CH,
		#948D87 66CH,
		#75706A 78CH,
		#57534C 90CH,
		#302F2B 102CH,
		#1F1A14
	) Calc(50% - 57CH - .875IN) Center / 114CH 100%, Fixed Repeat-Y Linear-Gradient(
		To Right,
		#FAF8F7 30CH,
		#DEDBD9 42CH,
		#B8B3B0 54CH,
		#948D87 66CH,
		#75706A 78CH,
		#57534C 90CH,
		#302F2B 102CH,
		#1F1A14
	) Calc(50% + 57CH + .875IN) Center / 114CH 100%, #FAF8F7 }
	body { Color: #1F1A14 }
}
body {
	/* Properties related to horizontal sizing are `!important` for a reason—their values are expected in scripting. */
	Display: Block ! IMPORTANT;
	Box-Sizing: Content-Box ! IMPORTANT;
	Writing-Mode: Horizontal-TB ! IMPORTANT;
	Margin: 0 Auto !IMPORTANT;
	Border: None ! IMPORTANT ;
	Padding: 1IN .75IN 1IN 1IN ! IMPORTANT;
	Width: Calc(100VW - 1.75IN) ! IMPORTANT;
	Max-Width: 60CH ! IMPORTANT;
	Background: Transparent ! IMPORTANT;
	Font: Normal Medium / 1.35 Serif;
	Font-Variant-Numeric: Oldstyle-Nums;
	Text-Align: Justify;
	Hyphens: Auto;
}
header {
	Min-Height: 18EM;
	Font-Style: Italic;
	Line-Height: 1.5;
}
header::BEFORE {
	Display: Block;
	Float: Left;
	Width: 9EM;
	Height: 18EM;
	Shape-Outside: Polygon(0 0, 100% 100%, 0 100%);
	Content: "";
}
header::AFTER {
	Display: Block;
	Float: Left;
	Clear: Left;
	Width: 12EM;
	Height: 36EM;
	Shape-Outside: Polygon(0 0, 100% 0, 0 100%);
	Content: "";
}
header>*:Not(h1) {
	Display: Block;
	Position: Relative;
	Left: -9EM;
	Margin-Right: -9EM;
	Padding-Left: 9EM;
}
@supports Not ( Shape-Outside: Polygon(0 0, 100% 0, 0 100%) ) { /* Firefox ESR 60 support */
	header::BEFORE,
	header::AFTER { Width: 0EM }
}
nav,
section { Margin: 1IN 0 0 }
header+nav,
header+section { Margin-Top: 0 }

/* Horizontal article layout for screens */
article>*:Focus { Outline: None }
@media screen {
	article {
		Position: Relative; /* This needs to be a positioned containing element for scripting reasons */
		Writing-Mode: Vertical-LR;
		Text-Orientation: Sideways; /* For correct `ch` units */
		Margin: -1IN Calc(50% + .125IN - 50VW) -1IN Calc(50% - .125IN - 50VW);
		Width: 100VW;
		Height: 100VH;
		Overflow-X: Auto;
		Overflow-Y: Hidden;
	}
	article + article { Margin-Top: 1IN }
	article::BEFORE,
	article::AFTER {
		Display: Block;
		Width: Calc(50VW - .875IN - 30CH);
		Mix-Blend-Mode: Darken;
		Content: "";
	}
	article::BEFORE {
		Background: Linear-Gradient(
			To Left,
			#FAF8F7,
			#DEDBD9 8CH,
			#B8B3B0 16CH,
			#948D87 24CH,
			#75706A 32CH,
			#57534C 40CH,
			#302F2B 48CH,
			#1F1A14 56CH
		);
	}
	article::AFTER { Background: Linear-Gradient(
		To Right,
		#FAF8F7,
		#DEDBD9 8CH,
		#B8B3B0 16CH,
		#948D87 24CH,
		#75706A 32CH,
		#57534C 40CH,
		#302F2B 48CH,
		#1F1A14 56CH
	) }
	article>* {
		/* It is important that children of `article` have the same box sizing in the x direction as `body`, since the latter is used for calculating section widths. */
		Display: Block ! IMPORTANT;
		Position: Relative;
		Box-Sizing: Content-Box ! IMPORTANT;
		Writing-Mode: Horizontal-TB;
		Margin: 0 ! IMPORTANT ;
		Border: None ! IMPORTANT ;
		Padding: 1IN .75IN 1IN 1IN ! IMPORTANT;
		Width: Calc(100VW - 1.75IN) ! IMPORTANT;
		Max-Width: 60CH ! IMPORTANT;
		Height: Calc(100VH - 2IN) ! IMPORTANT;
		Overflow-X: Hidden;
		Overflow-Y: Scroll;
		Background: Transparent ! IMPORTANT;
	}
	article>*::AFTER {
		Display: Block;
		Margin: 0 0 -1IN;
		Padding: 1IN 0 0;
		Content: "";
	}
}

/* Basic styling */
h1 {
	Margin: 0;
	Font: 900 1EM / 3 Sans-Serif;
	Text-Transform: Uppercase;
	Hyphens: None;
}
h2 {
	Display: Inline-Block;
	Margin: 0 2CH 0 0;
	Font: 900 Small-Caps 1EM / 1 Sans-Serif;
	Text-Transform: Lowercase;
}
h2::AFTER {
	/*
	Ending an `h2` with an inline element with right padding forces a line­‑break in Firefox ( this right padding is evidently not taken into account when sizing the containing block, and then overflows ). Placing an empty inline block at the end of the element avoids this by ensuring that both sides of the padding are taken into account.
	*/
	Display: Inline-Block;
	Content: "";
}
blockquote {
	Position: Relative;
	Left: 4CH;
	Margin: 1.35EM 4CH 1.35EM 0;
	Padding: 0;
}
abbr { Font-Variant-Caps: Small-Caps }
b.LISTING {
	Margin: -1PX;
	Border: 1PX Solid;
	Border-Radius: 1.0125EM .675EM; /* This “ should ” be `.675EM` for all but Iʼve intentionally warped it. */
	Padding: .175EM .5CH;
}
b.NUMERIC.LISTING {
	Display: Inline-Block;
	Box-Sizing: Border-Box;
	Margin: -3PX;
	Border: 3PX Double;
	Height: Calc(1.35EM + 3PX);
	Min-Width: Calc(1.35EM + 3PX);
	Line-Height: 1;
	Text-Align: Center;
}
b.LEAD-IN { Font: 900 Small-Caps 1EM / 1 Sans-Serif }
b.TOMBSTONE {
	Display: Inline-Block;
	Padding: 0 .5CH;
	Color: #57534C;
	Font: 900 Small-Caps Smaller / 1 Sans-Serif;
	Font-Synthesis: None;
	White-Space: NoWrap;
	Vertical-Align: Middle;
}
em {
	/*
	THIS WILL LOOK WRONG IN EVERY MAJOR BROWSER ( at time of writing ). Both Firefox and WebKit ( and Edge, RIP ) apply letter­‑spacing after every character in a span, rather than simply in­‑between characters, meaning that the .2CH padding will be double­‑applied ( once through `padding` and once through `letter-spacing` ) at the end of each `em`. This is considered non­–⁠spec­‑conforming and an implementation bug by CSSWG ( see https://github.com/w3c/csswg-drafts/issues/1518, which resolved ⸰ not ⸰ to change the spec to match implementations ), so for forward­‑compatibility purposes this code assumes the specified ( but unimplemented, save in IE, RIP ) behaviour.
	*/
	Padding: 0 .2CH;
	Letter-Spacing: .2CH;
}
mark {
	Margin: -1PX;
	Padding: .07EM .5CH;
	Border: 1PX #EB91007F Solid;
	Box-Decoration-Break: Clone;
	Background: #FAE13E7F;
}
span.SCREENREADER {
	Position: Absolute;
	Width: 1PX;
	Height: 1PX;
	Clip-Path: Inset(50%);
	Overflow: Hidden;
	Z-Index: -1;
}
strong { Font-Variant-Caps: Small-Caps }
sup {
	Font: Normal XX-Small / 1 Serif;
	Text-Transform: None;
}
@media screen {
	/*
	`screen` adjustments for superscript links to boost their clickability.
	*/
	*:Root sup a[href] {
		Position: Relative;
		Margin: -.5EM Calc(.5CH - 1EM);
		Border-Style: Solid;
		Border-Color: Transparent;
		Border-Width: .25EM;
		Padding: .25EM Calc(.75EM - .5CH);
		Outline: Thin #B8B3B0 Solid;
		Color: Inherit;
		Background-Image: Repeating-Linear-Gradient(
			-60DEG,
			Transparent 0,
			Transparent 1PX,
			#DEDBD9 1.1547PX,
			#DEDBD9 2.1547PX,
			Transparent 2.3094PX
		);
		Outline-Offset: -.25EM;
		Mix-Blend-Mode: Multiply;
		Text-Decoration: None;
		Z-Index: 1;
	}
	sup a[href]:Focus,
	sup a[href]:Hover { Outline: Thin Solid }
	sup a[href]:Hover { Background-Image: Repeating-Linear-Gradient(
		-60DEG,
		Transparent 0,
		Transparent 1PX,
		#B8B3B0 1.1547PX,
		#B8B3B0 2.1547PX,
		Transparent 2.3094PX
	) }
}
time { Font-Variant-Caps: Small-Caps }
*:Link,
*:Visited {
	Margin: 0 -.5CH -1PX;
	Padding: .07EM .5CH;
	Border-Bottom: 1PX Solid;
	Box-Decoration-Break: Clone;
	Color: #4B2DF7; /* Applies to both in non­‑`screen` layouts */
	Background: None Padding-Box;
	Text-Decoration: None;
}
small *:Link,
small *:Visited { Border-Bottom-Style: Dashed }
@media screen {
	*:Visited { Color: #B01C1C }
}
*:Link:Focus,
*:Visited:Focus {
	Margin: -1PX Calc(-.5CH - 1PX) -2PX;
	Border-Style: Solid;
	Border-Width: 1PX 1PX 2PX;
	Outline: None;
}
small *:Link:Focus,
small *:Visited:Focus { Border-Style: Dashed Dashed Dotted }
*:Link:Active,
*:Visited:Active {
	Margin: -1PX Calc(-.5CH - 1PX) -2PX Calc(-.5CH - 2PX);
	Border-Width: 1PX 1PX 2PX 2PX;
}
small *:Link:Active,
small *:Visited:Active { Border-Style: Dashed Dashed Dotted Dotted }

/* Paragraph formatting */
p {
	Display: Inline;
	Margin: 0;
}
p+p {
	Display: Block;
	Text-Indent: 2CH;
}
p>* { Text-Indent: 0 }

/* List formatting */
ol,
ul {
	Margin: 1.35EM 0;
	Padding: 0;
	List-Style-Position: Inside;
}
@counter-style Decimal-Dot-Space { /* See CSS Counter Styles Level 3 ( Editorʼs Draft, 09 December 2018 ), only supported in Firefox at time of publication */
	System: Numeric;
	Symbols: "0" "1" "2" "3" "4" "5" "6" "7" "8" "9";
	Negative: "−";
	Suffix: ". ";
}
ol { List-Style-Type: Decimal-Dot-Space }
ul { List-Style-Type: None }
li {
	Position: Relative;
	Left: 6CH;
	Margin: 0 6CH 0 0;
	Text-Indent: -2CH; /* Will affect the marker regardless of contents */
}
li>* { Text-Indent: 0 }
li>p {
	Display: Block;
	Position: Relative;
	Left: -2CH;
	Margin: 0 -2CH 0 0;
}
li>p:Last-Child { Margin-Bottom: 1.35EM }
ol>li>p { Text-Indent: 2CH }
ol>li>p:First-Child { /* Shifts the paragraph up a line such that the marker is inside the indentation. */
	Margin-Top: -1.35EM;
	Text-Indent: 4CH;
}

/* Footer formatting */
footer {
	Position: Relative;
	Margin: 1.35EM 0 0;
	Border-Style: Solid None;
	Border-Width: 1.35EM 0;
	Padding: 1.35EM 0;
	Font-Size: Small;
	Z-Index: 0; /* New stacking context */
}
*:Root footer>*+* { Margin-Top: 1.35EM }
footer>nav {
	Display: Grid;
	Position: Relative;
	Grid-Template-Columns: 1FR 1FR 1FR;
	Margin: -3PX;
	Border: 3PX Double;
	Background: Padding-Box CurrentColor;
	Z-Index: 1;
}
footer>nav:Last-Child { Margin-Bottom: Calc(-2.7EM - 3PX) }
*:Root footer>nav>ol,
*:Root footer>nav>ul,
*:Root footer>nav>*>li { Display: Contents }
*:Root footer>nav>*>li>a[href] {
	Justify-Self: Center;
	Position: Relative;
	Top: 0;
	Margin: 0;
	Transition: Top Ease-In-Out .25S;
}
footer>nav>*>li>a[href]:Hover,
footer>nav>*>li>a[href]:Focus { Top: 1EX }
footer>nav>*>li>a[href]:Active { Top: 0 }
footer>nav>*>li:Nth-Of-Type(n+4)>a[href] {
	Top: Auto;
	Bottom: 0;
	Margin-Top: 1.35EM;
	Transition: Bottom Ease-In-Out .25S;
}
footer>nav>*>li:Nth-Of-Type(n+4)>a[href]:Hover,
footer>nav>*>li:Nth-Of-Type(n+4)>a[href]:Focus { Bottom: 1EX }
footer>nav>*>li:Nth-Of-Type(n+4)>a[href]:Active { Bottom: 0 }
footer>nav>*>li:Nth-Of-Type(3n+1)>a[href] {
	Justify-Self: Start;
	Top: 0;
	Bottom: 0;
	Left: 0;
	Text-Align: Left;
	Transition: Left Ease-In-Out .25S;
}
footer>nav>*>li:Nth-Of-Type(3n+0)>a[href] {
	Justify-Self: End;
	Top: 0;
	Bottom: 0;
	Right: 0;
	Text-Align: Right;
	Transition: Right Ease-In-Out .25S;
}
footer>ol>li small.RETURN,
footer>ol>li small.RETURN>* { Display: None }
@media screen {
	footer>ol>li:Target small.RETURN {
		Display: Block;
		Position: Absolute;
		Top: -1.35EM;
		Left: 0;
		Right: 0;
		Bottom: 0;
		Font: Inherit;
		Text-Align: Right;
		Z-Index: 0;
		Pointer-Events: None;
	}
	footer>ol>li:Target small.RETURN::BEFORE {
		Display: Block;
		Position: Sticky;
		Top: -1IN;
		Margin: 0 0 -1.35EM;
		Height: 1.35EM;
		Background: #1F1A14;
		Z-Index: -1;
		Pointer-Events: Auto;
		Content: "";
	}
}
footer>ol>li:Target small.RETURN>a[href]:First-Child,
*:Root footer>nav>*>li>a[href],
footer>a[href]:Last-Child {
	Display: Block;
	Border: 1PX Solid;
	Padding: .07EM .5CH;
	Height: 1.35EM;
	Color: Inherit;
	Background: #FAF8F7;
	Font: Normal Small / 1.35 Serif;
	Pointer-Events: Auto;
}
footer>ol>li:Target small.RETURN>a[href]:First-Child::AFTER,
footer>nav>*>li>a[href]::AFTER,
footer>a[href]:Last-Child::AFTER {
	Position: Absolute;
	Top: -1EX;
	Bottom: -1EX;
	Left: -4CH;
	Right: -4CH;
	Z-Index: -1;
	Content: "";
}
footer>ol>li:Target small.RETURN>a[href]:First-Child,
footer>a[href]:Last-Child {
	Margin: Calc(-1PX - .07EM) Calc(-1PX - .5CH);
	Text-Align: Right;
	Transition: Right Ease-In-Out .25S;
}
footer>ol>li:Target small.RETURN>a[href]:First-Child {
	Display: Inline-Block;
	Position: Sticky;
	Top: Calc(-1IN - 1PX - .07EM);
	Right: Calc(-1PX - .5CH);
	Bottom: Auto;
}
footer>a[href]:Last-Child {
	Position: Absolute;
	Bottom: -1.35EM;
	Right: 0;
}
*:Root:Root footer>a[href="#"]:Last-Child {
	Right: Auto;
	Left: 0;
	Text-Align: Left;
	Transition: Left Ease-In-Out .25S;
}
footer>ol>li:Target small.RETURN>a[href]:First-Child:Hover,
footer>ol>li:Target small.RETURN>a[href]:First-Child:Focus { Right: Calc(1.5CH - 1PX) }
footer>nav>*>li:Nth-Of-Type(3n+0)>a[href]:Hover,
footer>nav>*>li:Nth-Of-Type(3n+0)>a[href]:Focus,
footer>a[href]:Last-Child:Hover,
footer>a[href]:Last-Child:Focus { Right: 2CH }
footer>nav>*>li:Nth-Of-Type(3n+1)>a[href]:Hover,
footer>nav>*>li:Nth-Of-Type(3n+1)>a[href]:Focus,
*:Root footer>a[href="#"]:Last-Child:Hover,
*:Root footer>a[href="#"]:Last-Child:Focus { Left: 2CH }
footer>ol>li:Target small.RETURN>a[href]:First-Child:Focus,
footer>nav>*>li>a[href]:Focus,
footer>a[href]:Last-Child:Focus { Text-Decoration: Dashed Underline }
footer>ol>li:Target small.RETURN>a[href]:First-Child:Active,
footer>nav>*>li>a[href]:Active,
*:Root footer>a[href]:Last-Child:Active { Transition: None }
footer>ol>li:Target small.RETURN>a[href]:First-Child:Active { Right: Calc(-1PX - .5CH) }
footer>nav>*>li>li:Nth-Of-Type(3n+0)>a[href]:Active,
footer>a[href]:Last-Child:Active { Right: 0 }
footer>nav>*>li>li:Nth-Of-Type(3n+1)>a[href]:Active,
*:Root footer>a[href="#"]:Last-Child:Active { Left: 0 }
footer>ol { Margin: 0 }
footer>ol>li {
	Position: Static;
	Margin: 0;
	Text-Indent: 0;
}
footer>ol>li:Target {
	Margin: Calc(-1.35EM - 1PX) Calc(-.5CH - 1PX) -1PX;
	Border-Style: Solid None None;
	Border-Color: Transparent;
	Border-Width: 1.35EM 0 0;
	Padding: 1PX Calc(.5CH + 1PX);
	Background: Padding-Box #FAF8F7;
	Box-Shadow: Inset 0 0 0 1PX #1F1A14;
}
footer>ol>li:Target::AFTER {
	Display: Block;
	Position: Absolute;
	Top: 0;
	Bottom: 0;
	Left: 0;
	Right: 0;
	Background: #DEDBD9;
	Z-Index: -1;
	Content: "";
}
*:Root footer>ol>li>p {
	Position: Static;
	Margin: 0;
}
footer>ol>li>p:First-Child {
	Display: Inline;
	Text-Indent: 0;
}
</style>

<article>
	<div tabindex="0" id="introduction">
		<header>
			<h1>Tendency<br />Style</h1>
			<p><small>Last updated : <time datetime="2019-04-07">07 April 2019</time></small></p>
		</header>
		<p><b class="LEAD-IN">This styling is blatantly ripped</b> from the 1994 Routledge edition of Eve Kosofsky Sedgwickʼs <a href="http://985queer.queergeektheory.org/wp-content/uploads/2013/04/Tendencies.pdf" rel="noopener noreferrer"><cite>Tendencies</cite></a>. You can see it in­‑use on <a href="https://www.u2764.com/page03.xhtml">page 03 of my journal</a>.
		<p>Page content should either all be inside <code>&lt;body></code> or inside of an  <code>&lt;article></code> child ; in the latter case, each element child of the  <code>&lt;article></code> will create a separate scrollbox, laid out horizontally like on this page. The hope with this design is that it will make longer articles easier to read in multiple passes, as flipping <em>between</em> sections is a simple matter of horizontal scrolling, while scanning <em>within</em> sections happens along the vertical. You can use a <code>&lt;div></code> to wrap content ( such as the header and introductory section ) which should go together. On non­‑<code>screen</code> devices ( eg, when printing ) both layouts are approximately the same.
		<p>For ease of navigation, this page is scripted ; the scripts simply provide scroll­‑snapping and autofocusing features to make the page navigate in an intuitive manner via mouse or keyboard. All styling is done via CSS ; the page works fine with JavaScript disabled.
		<p>It is recommended, but not required, that you set <code>tabindex="0"</code> on the children of <code>&lt;article></code> for ease­‑of­‑navigation purposes.
		<p>Footnotes can be created using links inside of <code>&lt;sup></code> elements, like this<sup id="introduction.m1"><a href="#introduction.n1">1</a></sup> ; the notes themselves should be placed in a <code>&lt;ol></code> in a <code>&lt;footer></code> at the bottom of the page. Use <code>&lt;small class="RETURN">&lt;a href="#mark-id">[Return to text.]&lt;/a>&lt;/small></code> or similar to provide a return link from footnotes ; these will only be rendered visually when the containing list item is targeted.
		<p><code>&lt;footer></code>s also provide useful navigation features for people without horizontal scrolling capabilities ; a link which is the last child of the <code>&lt;footer></code> element will be displayed in a special manner, intended for use as a link targeting the following section. See the footer at the bottom of this page for an example. If the <code>href</code> of this link is an exact match for <code>"#"</code>, then it is a toplink and will be left­‑justified instead of right‑.
		<p>If you need more advanced navigation capabilities, you can use a <code>&lt;nav></code> containing a list of links inside the <code>&lt;footer></code> instead ; this will be rendered as a 3×<i>n</i> grid.
		<footer>
			<ol>
				<li id="introduction.n1">This is a footnote.<small class="RETURN"> <a href="#introduction.m1">[ Return to text. ]</a></small>
			</ol>
			<a href="#classes">[ Continue ⇒ ]</a>
		</footer>
	</div>
	<section id="classes" tabindex="0">
		<h2>Classes</h2>
		<p>There are a number of special classes that you can use in your document :— <b class="NUMERIC LISTING">1.</b> <code>&lt;b></code> elements can be given the class <code>"LISTING"</code> ( for words ) or <code>"NUMERIC LISTING"</code> ( for numerals ) to draw a ring around numbers or other inline prose list markers ; <b class="NUMERIC LISTING">2.</b> <code>&lt;b></code> elements can also be given the class <code>"LEAD-IN"</code> to add a lead­‑in to a section without a heading, or <code>"TOMBSTONE"</code> for an end­‑of­‑article mark ; and <b class="NUMERIC LISTING">3.</b> <code>&lt;span class="SCREENREADER"></code> is available for text which should be read but not seen.<b class="TOMBSTONE">∎<span class="SCREENREADER"> [ End of article. ]</span></b></p>
		<footer>
			<a href="#">[ ⇑ Top ]</a>
		</footer>
	</section>
</article>

<script>
/*
These scripts provide scrolling support to ensure that the current section will always be centred on the page, and that keyboard navigation will function as expected. Make sure they run after the DOM content for the rest of the page is loaded, or else they wonʼt work.

( These scripts *only* provide scrolling support. All page styling is done via the CSS, above. )
*/
( ( )  =>  {
	"use strict"
	let screenStatus  =  matchMedia( "screen" )
	Array.prototype.forEach.call(
		document.body.getElementsByTagName( "article" )
		, ( element )  =>  {
			var
				isSmoothScrolling  =  false
				, lastSnap  =  ( ( )  =>  {
					let sectionWidth  =  document.body.offsetWidth
					return element.scrollLeft  =  sectionWidth * Math.round( element.scrollLeft / sectionWidth )
				} )( )
				, timeout  =  null
			element.addEventListener(
				"scroll"
				, ( event )  =>  {
					/*
					500MS after an `article` is scrolled, its scroll position is snapped to a section. If the article was scrolled less than 72PX ( .75IN ), it will snap to the nearest section ( which will be the one it is already on ). If it is scrolled more than one sectionʼs width, it will snap to whichever section is nearest. Otherwise, it will snap to the next section in the direction scrolled ( computed from the previous snap ).
					*/
					if ( !screenStatus.matches )  return
					if ( timeout != null )  clearTimeout( timeout )
					timeout  =  setTimeout( ( )  =>  {
						let
							roundingMode  =  Math.abs( lastSnap - element.scrollLeft ) > document.body.offsetWidth  ||  72 > Math.abs( lastSnap - element.scrollLeft )  ?  "round"  :  ( lastSnap > element.scrollLeft  ?  "floor"  :  "ceil" )
							, sectionWidth  =  document.body.offsetWidth
							, sectionToFocus  =  Math[ roundingMode ]( element.scrollLeft / sectionWidth )
						if ( element.scrollLeft == sectionWidth * sectionToFocus )  if ( isSmoothScrolling  ||  element.scrollLeft != lastSnap )  {
							/*
							This is the completion of a previous scroll. The current element is focused so that up/down keyboard navigation will function as expected.
							*/
							isSmoothScrolling  =  false
							try  { element.children[ sectionToFocus ].focus( ) }
							catch ( e )  { }
							return
						}
						isSmoothScrolling  =  true
						element.scrollTo( {
							behavior: "smooth"
							, left: lastSnap  =  sectionWidth * sectionToFocus
						} )
					}, 500 )
				}
			)
		}
	)
	Array.prototype.forEach.call(
		document.body.querySelectorAll( `article>*` )
		, ( element )  =>  [
			"click"
			, "focusin"
		].forEach( ( name )  =>  element.addEventListener(
			name
			, ( event )  =>  {
				/*
				Clicking on a section will immediately scroll it into view.
				*/
				let parent = element.parentNode
				if ( !screenStatus.matches )  return
				parent.scrollLeft  =  element.offsetLeft - parseFloat( getComputedStyle(
					parent
					, "::before"
				).getPropertyValue( "Width" ) )
			}
		) )
	)
	;  [
		"hashchange"
		, "load"
		, "resize"
		, "change"
	].forEach( ( name )  =>  ( name == "change" ? screenStatus.addEventListener : addEventListener )(
		name
		, ( event )  =>  {
			/*
			On hashchange/resize/load, or when the media type changes to `screen`, sections are manually scrolled into view.
			*/
			var
				article
				, parent
				, section
			let
				hash  =  location.hash.substring( 1 )
				, element  =  hash  ?  document.getElementById( hash )  :  null
			if ( !screenStatus.matches )  return
			if ( name == "resize" )  {
				/*
				On `resize` events, we just simulate a scroll and let the `article` code handle it.
				*/
				console.log("resized")
				Array.prototype.forEach.call(
					document.body.getElementsByTagName( "article" )
					, ( eachArticle )  =>  eachArticle.dispatchEvent( new Event( "scroll" ) )
				)
				return
			}
			if ( hash == "" )  {
				article = document.body.getElementsByTagNameNS(
					"http://www.w3.org/1999/xhtml"
					, "article"
				).item( 0 )
				if ( !article )  return
				section  =  article.firstElementChild
				if ( !section )  return
			}
			else  {
				if ( !( section  =  element )  ||  !( parent  =  element.parentNode ) )  return
				while ( !article )  {
					if ( parent.localName == "article" )  if ( parent.namespaceURI == "http://www.w3.org/1999/xhtml" )  article  =  parent
					if ( !article )  if ( !( ( section  =  parent ), ( parent  =  parent.parentNode ) ) )  return
				}
			}
			;  ( element  ||  section ).focus( )
			if ( section == element )  event.preventDefault( )
		}
	) )
	Array.prototype.forEach.call(
		document.body.querySelectorAll( "a[href^=\"#\"]" )
		, ( element )  =>  element.addEventListener(
			"click"
			, ( event )  =>  {
				/*
				Clicking on a hash link will fire a `hashchange` event even if the hash does not actually change.
				*/
				if ( !screenStatus.matches )  return
				if ( element.href == location )  {
					requestAnimationFrame( ( )  =>  dispatchEvent( new HashChangeEvent(
						"hashchange"
						, {
							oldURL: location
							, newURL: location
						}
					) ) )
					event.preventDefault( )
				}
			}
		)
	)
} )( )
</script>